---
title: 前端缓存
date: 2018-06-13 14:31:52
tags: [前端, 缓存, http, 计算机网络]
---

# 缓存分类
&emsp;&emsp;web缓存分为很多种，比如数据库缓存、代理服务器缓存、还有我们熟悉的CDN缓存，以及浏览器缓存。对于太多文字的阅读其实我是拒绝的，于是就画了个图来解释下。
{% asset_img 1.PNG  浏览器通过代理服务器向源服务器发起请求的原理图 %}
&emsp;&emsp;浏览器先向代理服务器发起Web请求，再将请求转发到源服务器。它属于共享缓存，所以很多地方都可以使用其缓存资源，因此对于节省流量有很大作用。
&emsp;&emsp;浏览器缓存是将文件保存在客户端，在同一个会话过程中会检查缓存的副本是否足够新，在后退网页时，访问过的资源可以从浏览器缓存中拿出使用。通过减少服务器处理请求的数量，用户将获得更快的体验
<!-- more -->
# 浏览器缓存
页面的缓存状态是由header决定的，header的参数有四种：
## Cache-Control
### max-age
max-age（单位为s）指定设置缓存最大的有效时间，定义的是时间长短。当浏览器向服务器发送请求后，在max-age这段时间里浏览器就不会再向服务器发送请求了。

我们来找个资源看下。比如shang.qq.com上的css资源，max-age=2592000，也就是说缓存有效期为2592000秒（也就是30天）。于是在30天内都会使用这个版本的资源，即使服务器上的资源发生了变化，浏览器也不会得到通知。max-age会覆盖掉Expires，后面会有讨论。
{% asset_img 2.png  max-age请求图 %}
### s-maxage
s-maxage（单位为s）同max-age，只用于共享缓存（比如CDN缓存）。
比如，当s-maxage=60时，在这60秒中，即使更新了CDN的内容，浏览器也不会进行请求。也就是说max-age用于普通缓存，而s-maxage用于代理缓存。如果存在s-maxage，则会覆盖掉max-age和Expires header。
### public
public 指定响应会被缓存，并且在多用户间共享。也就是下图的意思。如果没有指定是public还是private，则默认为public。
{% asset_img 3.png  public请求图 %}
### private 
private 响应只作为私有的缓存（见下图），不能在用户间共享。如果要求HTTP认证，响应会自动设置为private。
{% asset_img 4.png  private请求图 %}
### no-cache
no-cache 指定不缓存响应，表明资源不进行缓存，比如，
{% asset_img 5.png  no-cache请求图 %}
但是设置了no-cache之后并不代表浏览器不缓存，而是在缓存前要向服务器确认资源是否被更改。因此有的时候只设置no-cache防止缓存还是不够保险，还可以加上private指令，将过期时间设为过去的时间。
### no-store
no-store 绝对禁止缓存，一看就知道如果用了这个命令当然就是不会进行缓存啦～每次请求资源都要从服务器重新获取。
### must-revalidate
must-revalidate指定如果页面是过期的，则去服务器进行获取。这个指令并不常用，就不做过多的讨论了。

```bash
s-maxage > max-age > Expires > Last-Modified
```
## Expires
&emsp;&emsp;缓存过期时间，用来指定资源到期的时间，是服务器端的具体的时间点。也就是说，Expires=max-age + 请求时间，需要和Last-modified结合使用。但在上面我们提到过，cache-control的优先级更高。 Expires是Web服务器响应消息头字段，在响应http请求时告诉浏览器在过期时间前浏览器可以直接从浏览器缓存取数据，而无需再次请求。
{% asset_img 6.png  Expires请求图 %}
## Last-modified
&emsp;&emsp;服务器端文件的最后修改时间，需要和cache-control共同使用，是检查服务器端资源是否更新的一种方式。当浏览器再次进行请求时，会向服务器传送If-Modified-Since报头，询问Last-Modified时间点之后资源是否被修改过。如果没有修改，则返回码为304，使用缓存；如果修改过，则再次去服务器请求资源，返回码和首次请求相同为200，资源为服务器最新资源。
如下图，最后修改时间为2014年12月19日星期五2点50分47秒
{% asset_img 7.png  Last-modified请求图 %}
## ETag
&emsp;&emsp;根据实体内容生成一段hash字符串，标识资源的状态，由服务端产生。浏览器会将这串字符串传回服务器，验证资源是否已经修改，如果没有修改，过程如下：
{% asset_img 8.png  ETag请求图 %}
使用ETag可以解决Last-modified存在的一些问题：
- 某些服务器不能精确得到资源的最后修改时间，这样就无法通过最后修改时间判断资源是否更新。
- 如果资源修改非常频繁，在秒以下的时间内进行修改，而Last-modified只能精确到秒。
- 一些资源的最后修改时间改变了，但是内容没改变，使用ETag就认为资源还是没有修改的。

# 使用缓存流程
还是用图说话，下面是我所总结的从浏览器请求到展示资源的过程：
{% asset_img 9.png  浏览器请求到展示资源的过程图 %}
## cache-control指令使用
{% asset_img 10.png  cache-control指令使用 %}



# 参考
[前端必须知道的http缓存 ](https://github.com/Pines-Cheng/blog/issues/5)
[浅谈web缓存](http://www.alloyteam.com/2016/03/discussion-on-web-caching/)
