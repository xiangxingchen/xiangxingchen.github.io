---
title: 前端静态资源缓存策略
date: 2018-06-14 16:31:56
tags: [前端,缓存]
---

# 效果
对于页面中静态资源（html/js/css/img/webfont），理想中的效果：

- 页面以最快的速度获取到所有必须静态资源，渲染飞快；
- 服务器上静态资源未更新时再次访问不请求服务器；
- 服务器上静态资源更新时请求服务器最新资源，加载又飞快。

总结下来也就是2个指标：

- 静态资源加载速度
- 页面渲染速度

# 性能优化原则及分类
| 优化方向 | 优化手段 |
| - | - |
| 请求数量 | 合并脚本和样式表，CSS Sprites，拆分初始化负载，划分主域 |
| 请求带宽 | 开启GZip，精简JavaScript，移除重复脚本，图像优化 |
| 缓存利用 | 使用CDN，使用外部JavaScript和CSS，添加Expires头，减少DNS查找，配置ETag，使AjaX可缓存 |
| 页面结构 | 将样式表放在顶部，将脚本放在底部，尽早刷新文档的输出 |
| 代码校验 | 避免CSS表达式，避免重定向 |

目前大多数前端团队可以利用 yui compressor 或者 google closure compiler 等压缩工具很容易做到 精简Javascript 这条原则；同样的，也可以使用图片压缩工具对图像进行压缩，实现 图像优化 原则。这两条原则是对单个资源的处理，因此不会引起任何工程方面的问题。很多团队也通过引入代码校验流程来确保实现 避免css表达式 和 避免重定向 原则。目前绝大多数互联网公司也已经开启了服务端的Gzip压缩，并使用CDN实现静态资源的缓存和快速访问；一些技术实力雄厚的前端团队甚至研发出了自动CSS Sprites工具，解决了CSS Sprites在工程维护方面的难题。使用“查找-替换”思路，我们似乎也可以很好的实现 划分主域 原则。

# 静态资源版本更新与缓存
缓存利用分类中保留了 添加`Expires`头 和 配置`ETag` 两项。或许有些人会质疑，明明这两项只要配置了服务器的相关选项就可以实现，为什么说它们难以解决呢？确实，开启这两项很容易，但开启了缓存后，我们的项目就开始面临另一个挑战： 如何更新这些缓存？
相信大多数团队也找到了类似的答案，它和《高性能网站建设指南》关于“添加Expires头”所说的原则一样——修订文件名。即：
> 最有效的解决方案是修改其所有链接，这样，全新的请求将从原始服务器下载最新的内容。

思路没错，但要怎么改变链接呢？变成什么样的链接才能有效更新缓存，又能最大限度避免那些没有修改过的文件缓存不失效呢？

先来看看现在一般前端团队的做法：
```html
<h1>hello world</h1>

<script type="text/javascript" src="a.js?t=201404231123"></script>
<script type="text/javascript" src="b.js?t=201404231123"></script>
<script type="text/javascript" src="c.js?t=201404231123"></script>
<script type="text/javascript" src="d.js?t=201404231123"></script>
<script type="text/javascript" src="e.js?t=201404231123"></script>
```
> ps: 也有团队采用构建版本号为静态资源请求添加query，它们在本质上是没有区别的，在此就不赘述了。

接下来，项目升级，比如页面上的html结构发生变化，对应还要修改 a.js 这个文件，得到的构建结果如下：
```html
<header>hello world</header>

<script type="text/javascript" src="a.js?t=201404231826"></script>
<script type="text/javascript" src="b.js?t=201404231826"></script>
<script type="text/javascript" src="c.js?t=201404231826"></script>
<script type="text/javascript" src="d.js?t=201404231826"></script>
<script type="text/javascript" src="e.js?t=201404231826"></script>
```
为了触发用户浏览器的缓存更新，我们需要更改静态资源的url地址，如果采用构建信息（时间戳、版本号等）作为url修改的依据，如上述代码所示，我们只修改了一个a.js文件，但再次构建会让所有请求都更改了url地址，用户再度访问页面那些没有修改过的静态资源的(b.js，b.js，c.js，d.js，e.js)的浏览器缓存也一同失效了。

> 使用构建信息作为静态资源更新标记会导致每次构建发布后所有静态资源都被迫更新，浏览器缓存利用率降低，给性能带来伤害。

此外，采用添加query的方式来清除缓存还有一个弊端，就是`覆盖式发布`的上线问题。
{% asset_img deploy.png  覆盖式发布 %}

采用`query`更新缓存的方式实际上要覆盖线上文件的，`index.html`和`a.js`总有一个先后的顺序，从而中间出现一段或大或小的时间间隔。尤其是当页面是后端渲染的模板的时候，静态资源和模板是部署在不同的机器集群上的，上线的过程中，静态资源和页面文件的部署时间间隔可能会非常长，对于一个大型互联网应用来说即使在一个很小的时间间隔内，都有可能出现新用户访问。在这个时间间隔中，访问了网站的用户会发生什么情况呢？
- 如果先覆盖`index.html`，后覆盖`a.js`，用户在这个时间间隙访问，会得到新的`index.html`配合旧的`a.js`的情况，从而出现错误的页面。
- 如果先覆盖`a.js`，后覆盖`index.html`，用户在这个间隙访问，会得到旧的`index.html`配合新的`a.js`的情况，从而也出现了错误的页面。
这就是为什么大型web应用在版本上线的过程中经常会较集中的出现前端报错日志的原因，也是一些互联网公司选择加班到半夜等待访问低峰期再上线的原因之一。

对于静态资源缓存更新的问题，目前来说最优方案就是 基于文件内容的hash版本冗余机制 了。也就是说，我们希望项目源码是这么写的：
```js
<script type="text/javascript" src="a.js"></script>
```
发布后代码变成
```js
<script type="text/javascript" src="a_8244e91.js"></script>
```
也就是`a.js`发布出来后被修改了文件名，产生一个新文件，并不是覆盖已有文件。其中`_82244e91`这串字符是根据`a.js`的文件内容进行`hash`运算得到的，只有文件内容发生变化了才会有更改。由于将文件发布为带有`hash`的新文件，而不是同名文件覆盖，因此不会出现上述说的那些问题。同时，这么做还有其他的好处：
- 上线的`a.js`不是同名文件覆盖，而是文件名+`hash`的冗余，所以可以先上线静态资源，再上线`html`页面，不存在间隙问题；
- 遇到问题回滚版本的时候，无需回滚`a.js`，只须回滚页面即可；
- 由于静态资源版本号是文件内容的`hash`，因此所有静态资源可以开启永久强缓存，只有更新了内容的文件才会缓存失效，缓存利用率大增；

> 以文件内容的hash值为依据生产新文件的非覆盖式发布策略是解决静态资源缓存更新最有效的手段。

虽然这种方案是相比之下最完美的解决方案，但它无法通过手工的形式来维护，因为要依靠手工的形式来计算和替换hash值，并生成相应的文件，将是一项非常繁琐且容易出错的工作，因此我们需要借助工具来处理。

用grunt来实现md5功能是非常困难的，因为grunt只是一个task管理器，而md5计算需要构建工具具有递归编译的能，而不是简单的任务调度。考虑这样的例子：
{% asset_img md5.png  %}
由于我们的资源版本号是通过对文件内容进行hash运算得到，如上图所示，`index.html`中引用的`a.css`文件的内容其实也包含了`a.png`的`hash`运算结果，因此我们在修改`index.html`中`a.css`的引用时，不能直接计算`a.css`的内容`hash`，而是要先计算出`a.png`的内容`hash`，替换`a.css`中的引用，得到了`a.css`的最终内容，再做`hash`运算，最后替换`index.html`中的引用。
> 计算`index.html`中引用的`a.css`文件的url过程：
> 压缩`a.png`后计算其内容的md5值
> 将`a.png`的`md5`写入`a.css`，再压缩`a.css`，计算其内容的md5值
> 将`a.css`的`md5`值写入到`index.html`中

`grunt`等`task-based`的工具是很难在task之间协作处理这样的需求的。
在解决了基于内容hash的版本更新问题之后，我们可以将所有前端静态资源开启永久强缓存，每次版本发布都可以首先让静态资源全量上线，再进一步上线模板或者页面文件，再也不用担心各种缓存和时间间隙的问题了！


## 参考
1. [Web静态资源缓存及优化](https://zhuanlan.zhihu.com/p/30780216)
2. [前端工程与性能优化](https://github.com/fouber/blog/issues/3)
